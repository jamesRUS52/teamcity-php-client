<?php
/**
 * BuildTypeApi
 * PHP version 5
 *
 * @category Class
 * @package  TeamCityClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * TeamCity REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2018.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace TeamCityClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use TeamCityClient\ApiException;
use TeamCityClient\Configuration;
use TeamCityClient\HeaderSelector;
use TeamCityClient\ObjectSerializer;

/**
 * BuildTypeApi Class Doc Comment
 *
 * @category Class
 * @package  TeamCityClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BuildTypeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addAgentRequirement
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\AgentRequirement
     */
    public function addAgentRequirement($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addAgentRequirementWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addAgentRequirementWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAgentRequirementWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->addAgentRequirementRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addAgentRequirementAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAgentRequirementAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addAgentRequirementAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAgentRequirementAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAgentRequirementAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->addAgentRequirementRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addAgentRequirementRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addArtifactDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\ArtifactDependency
     */
    public function addArtifactDep($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addArtifactDepWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addArtifactDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function addArtifactDepWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->addArtifactDepRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addArtifactDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addArtifactDepAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addArtifactDepAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addArtifactDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addArtifactDepAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->addArtifactDepRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addArtifactDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addArtifactDepRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addArtifactDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBuildType
     *
     * @param  \TeamCityClient\Model\BuildType $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildType
     */
    public function addBuildType($body = null, $fields = null)
    {
        list($response) = $this->addBuildTypeWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation addBuildTypeWithHttpInfo
     *
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBuildTypeWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->addBuildTypeRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBuildTypeAsync
     *
     * 
     *
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildTypeAsync($body = null, $fields = null)
    {
        return $this->addBuildTypeAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBuildTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildTypeAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->addBuildTypeRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBuildType'
     *
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addBuildTypeRequest($body = null, $fields = null)
    {

        $resourcePath = '/app/rest/buildTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addFeature
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Feature $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Feature
     */
    public function addFeature($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addFeatureWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addFeatureWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFeatureWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->addFeatureRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addFeatureAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFeatureAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addFeatureAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFeatureAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFeatureAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->addFeatureRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addFeatureRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addFeatureParameter
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $parameter_name parameter_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function addFeatureParameter($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        list($response) = $this->addFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body);
        return $response;
    }

    /**
     * Operation addFeatureParameterWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addFeatureParameterRequest($bt_locator, $feature_id, $parameter_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addFeatureParameterAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFeatureParameterAsync($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        return $this->addFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFeatureParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addFeatureParameterRequest($bt_locator, $feature_id, $parameter_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFeatureParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addFeatureParameterRequest($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addFeatureParameter'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling addFeatureParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling addFeatureParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addSnapshotDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\SnapshotDependency
     */
    public function addSnapshotDep($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addSnapshotDepWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addSnapshotDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function addSnapshotDepWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->addSnapshotDepRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addSnapshotDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSnapshotDepAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addSnapshotDepAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addSnapshotDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSnapshotDepAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->addSnapshotDepRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addSnapshotDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addSnapshotDepRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addSnapshotDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addStep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Step $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Step
     */
    public function addStep($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addStepWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addStepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function addStepWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->addStepRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addStepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStepAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addStepAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addStepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStepAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->addStepRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addStepRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addStepParameter
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $parameter_name parameter_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function addStepParameter($bt_locator, $step_id, $parameter_name, $body = null)
    {
        list($response) = $this->addStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name, $body);
        return $response;
    }

    /**
     * Operation addStepParameterWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function addStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addStepParameterRequest($bt_locator, $step_id, $parameter_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addStepParameterAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStepParameterAsync($bt_locator, $step_id, $parameter_name, $body = null)
    {
        return $this->addStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addStepParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addStepParameterRequest($bt_locator, $step_id, $parameter_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addStepParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addStepParameterRequest($bt_locator, $step_id, $parameter_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addStepParameter'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling addStepParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling addStepParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTemplate
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\BuildType $body body (optional)
     * @param  bool $optimize_settings optimize_settings (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildType
     */
    public function addTemplate($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        list($response) = $this->addTemplateWithHttpInfo($bt_locator, $body, $optimize_settings, $fields);
        return $response;
    }

    /**
     * Operation addTemplateWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTemplateWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->addTemplateRequest($bt_locator, $body, $optimize_settings, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTemplateAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTemplateAsync($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        return $this->addTemplateAsyncWithHttpInfo($bt_locator, $body, $optimize_settings, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTemplateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTemplateAsyncWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->addTemplateRequest($bt_locator, $body, $optimize_settings, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addTemplateRequest($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($optimize_settings !== null) {
            $queryParams['optimizeSettings'] = ObjectSerializer::toQueryValue($optimize_settings);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTrigger
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Trigger
     */
    public function addTrigger($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addTriggerWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addTriggerWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTriggerWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->addTriggerRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTriggerAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTriggerAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addTriggerAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTriggerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTriggerAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->addTriggerRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addTriggerRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addVcsRootEntry
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootEntry
     */
    public function addVcsRootEntry($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->addVcsRootEntryWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation addVcsRootEntryWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function addVcsRootEntryWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->addVcsRootEntryRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addVcsRootEntryAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVcsRootEntryAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->addVcsRootEntryAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addVcsRootEntryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVcsRootEntryAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->addVcsRootEntryRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addVcsRootEntry'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addVcsRootEntryRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addVcsRootEntry'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeArtifactDepSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function changeArtifactDepSetting($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        list($response) = $this->changeArtifactDepSettingWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation changeArtifactDepSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeArtifactDepSettingWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeArtifactDepSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeArtifactDepSettingAsync($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        return $this->changeArtifactDepSettingAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeArtifactDepSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeArtifactDepSettingAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeArtifactDepSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling changeArtifactDepSetting'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling changeArtifactDepSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling changeArtifactDepSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeFeatureSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $name name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function changeFeatureSetting($bt_locator, $feature_id, $name, $body = null)
    {
        list($response) = $this->changeFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name, $body);
        return $response;
    }

    /**
     * Operation changeFeatureSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeFeatureSettingRequest($bt_locator, $feature_id, $name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeFeatureSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeFeatureSettingAsync($bt_locator, $feature_id, $name, $body = null)
    {
        return $this->changeFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeFeatureSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeFeatureSettingRequest($bt_locator, $feature_id, $name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeFeatureSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeFeatureSettingRequest($bt_locator, $feature_id, $name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling changeFeatureSetting'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling changeFeatureSetting'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling changeFeatureSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeRequirementSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function changeRequirementSetting($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        list($response) = $this->changeRequirementSettingWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation changeRequirementSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeRequirementSettingWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeRequirementSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRequirementSettingAsync($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        return $this->changeRequirementSettingAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeRequirementSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRequirementSettingAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeRequirementSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling changeRequirementSetting'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling changeRequirementSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling changeRequirementSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeStepSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function changeStepSetting($bt_locator, $step_id, $field_name, $body = null)
    {
        list($response) = $this->changeStepSettingWithHttpInfo($bt_locator, $step_id, $field_name, $body);
        return $response;
    }

    /**
     * Operation changeStepSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeStepSettingWithHttpInfo($bt_locator, $step_id, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeStepSettingRequest($bt_locator, $step_id, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeStepSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeStepSettingAsync($bt_locator, $step_id, $field_name, $body = null)
    {
        return $this->changeStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeStepSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeStepSettingRequest($bt_locator, $step_id, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeStepSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeStepSettingRequest($bt_locator, $step_id, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling changeStepSetting'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling changeStepSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling changeStepSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeTriggerSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function changeTriggerSetting($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        list($response) = $this->changeTriggerSettingWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation changeTriggerSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeTriggerSettingWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeTriggerSettingRequest($bt_locator, $trigger_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeTriggerSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeTriggerSettingAsync($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        return $this->changeTriggerSettingAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeTriggerSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeTriggerSettingAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->changeTriggerSettingRequest($bt_locator, $trigger_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeTriggerSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeTriggerSettingRequest($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling changeTriggerSetting'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling changeTriggerSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling changeTriggerSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAgentRequirement
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAgentRequirement($bt_locator, $agent_requirement_locator)
    {
        $this->deleteAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator);
    }

    /**
     * Operation deleteAgentRequirementWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator)
    {
        $returnType = '';
        $request = $this->deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAgentRequirementAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentRequirementAsync($bt_locator, $agent_requirement_locator)
    {
        return $this->deleteAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAgentRequirementAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator)
    {
        $returnType = '';
        $request = $this->deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling deleteAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllParameters
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllParameters($bt_locator)
    {
        $this->deleteAllParametersWithHttpInfo($bt_locator);
    }

    /**
     * Operation deleteAllParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllParametersWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteAllParametersRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParametersAsync($bt_locator)
    {
        return $this->deleteAllParametersAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParametersAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteAllParametersRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllParameters'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAllParametersRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteAllParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllParameters_0
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllParameters_0($bt_locator)
    {
        $this->deleteAllParameters_0WithHttpInfo($bt_locator);
    }

    /**
     * Operation deleteAllParameters_0WithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllParameters_0WithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteAllParameters_0Request($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllParameters_0Async
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParameters_0Async($bt_locator)
    {
        return $this->deleteAllParameters_0AsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllParameters_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParameters_0AsyncWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteAllParameters_0Request($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllParameters_0'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAllParameters_0Request($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteAllParameters_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArtifactDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteArtifactDep($bt_locator, $artifact_dep_locator)
    {
        $this->deleteArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator);
    }

    /**
     * Operation deleteArtifactDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteArtifactDepRequest($bt_locator, $artifact_dep_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArtifactDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArtifactDepAsync($bt_locator, $artifact_dep_locator)
    {
        return $this->deleteArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArtifactDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteArtifactDepRequest($bt_locator, $artifact_dep_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArtifactDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArtifactDepRequest($bt_locator, $artifact_dep_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteArtifactDep'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling deleteArtifactDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildType
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildType($bt_locator)
    {
        $this->deleteBuildTypeWithHttpInfo($bt_locator);
    }

    /**
     * Operation deleteBuildTypeWithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildTypeWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildTypeRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildTypeAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildTypeAsync($bt_locator)
    {
        return $this->deleteBuildTypeAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildTypeAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildTypeRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildType'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildTypeRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFeature
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFeature($bt_locator, $feature_id)
    {
        $this->deleteFeatureWithHttpInfo($bt_locator, $feature_id);
    }

    /**
     * Operation deleteFeatureWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFeatureWithHttpInfo($bt_locator, $feature_id)
    {
        $returnType = '';
        $request = $this->deleteFeatureRequest($bt_locator, $feature_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFeatureAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureAsync($bt_locator, $feature_id)
    {
        return $this->deleteFeatureAsyncWithHttpInfo($bt_locator, $feature_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFeatureAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureAsyncWithHttpInfo($bt_locator, $feature_id)
    {
        $returnType = '';
        $request = $this->deleteFeatureRequest($bt_locator, $feature_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFeatureRequest($bt_locator, $feature_id)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling deleteFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteParameter
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteParameter($name, $bt_locator)
    {
        $this->deleteParameterWithHttpInfo($name, $bt_locator);
    }

    /**
     * Operation deleteParameterWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteParameterWithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteParameterRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteParameterAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParameterAsync($name, $bt_locator)
    {
        return $this->deleteParameterAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParameterAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteParameterRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteParameter'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteParameterRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteParameter'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteParameter_0
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteParameter_0($name, $bt_locator)
    {
        $this->deleteParameter_0WithHttpInfo($name, $bt_locator);
    }

    /**
     * Operation deleteParameter_0WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteParameter_0WithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteParameter_0Request($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteParameter_0Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParameter_0Async($name, $bt_locator)
    {
        return $this->deleteParameter_0AsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteParameter_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParameter_0AsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteParameter_0Request($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteParameter_0'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteParameter_0Request($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteParameter_0'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteParameter_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSnapshotDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSnapshotDep($bt_locator, $snapshot_dep_locator)
    {
        $this->deleteSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator);
    }

    /**
     * Operation deleteSnapshotDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteSnapshotDepRequest($bt_locator, $snapshot_dep_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSnapshotDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSnapshotDepAsync($bt_locator, $snapshot_dep_locator)
    {
        return $this->deleteSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSnapshotDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteSnapshotDepRequest($bt_locator, $snapshot_dep_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSnapshotDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSnapshotDepRequest($bt_locator, $snapshot_dep_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteSnapshotDep'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling deleteSnapshotDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStep($bt_locator, $step_id)
    {
        $this->deleteStepWithHttpInfo($bt_locator, $step_id);
    }

    /**
     * Operation deleteStepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStepWithHttpInfo($bt_locator, $step_id)
    {
        $returnType = '';
        $request = $this->deleteStepRequest($bt_locator, $step_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStepAsync($bt_locator, $step_id)
    {
        return $this->deleteStepAsyncWithHttpInfo($bt_locator, $step_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStepAsyncWithHttpInfo($bt_locator, $step_id)
    {
        $returnType = '';
        $request = $this->deleteStepRequest($bt_locator, $step_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStepRequest($bt_locator, $step_id)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling deleteStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTrigger
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTrigger($bt_locator, $trigger_locator)
    {
        $this->deleteTriggerWithHttpInfo($bt_locator, $trigger_locator);
    }

    /**
     * Operation deleteTriggerWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTriggerWithHttpInfo($bt_locator, $trigger_locator)
    {
        $returnType = '';
        $request = $this->deleteTriggerRequest($bt_locator, $trigger_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTriggerAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTriggerAsync($bt_locator, $trigger_locator)
    {
        return $this->deleteTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTriggerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator)
    {
        $returnType = '';
        $request = $this->deleteTriggerRequest($bt_locator, $trigger_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTriggerRequest($bt_locator, $trigger_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling deleteTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVcsRootEntry
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVcsRootEntry($bt_locator, $vcs_root_locator)
    {
        $this->deleteVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator);
    }

    /**
     * Operation deleteVcsRootEntryWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = '';
        $request = $this->deleteVcsRootEntryRequest($bt_locator, $vcs_root_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVcsRootEntryAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVcsRootEntryAsync($bt_locator, $vcs_root_locator)
    {
        return $this->deleteVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVcsRootEntryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = '';
        $request = $this->deleteVcsRootEntryRequest($bt_locator, $vcs_root_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVcsRootEntry'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteVcsRootEntryRequest($bt_locator, $vcs_root_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteVcsRootEntry'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling deleteVcsRootEntry'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentRequirement
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\AgentRequirement
     */
    public function getAgentRequirement($bt_locator, $agent_requirement_locator, $fields = null)
    {
        list($response) = $this->getAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields);
        return $response;
    }

    /**
     * Operation getAgentRequirementWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentRequirementAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementAsync($bt_locator, $agent_requirement_locator, $fields = null)
    {
        return $this->getAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentRequirementAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling getAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentRequirements
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\AgentRequirements
     */
    public function getAgentRequirements($bt_locator, $fields = null)
    {
        list($response) = $this->getAgentRequirementsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAgentRequirementsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\AgentRequirements, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentRequirementsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirements';
        $request = $this->getAgentRequirementsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\AgentRequirements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentRequirementsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementsAsync($bt_locator, $fields = null)
    {
        return $this->getAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentRequirementsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirements';
        $request = $this->getAgentRequirementsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentRequirements'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentRequirementsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAgentRequirements'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAliases
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Items
     */
    public function getAliases($bt_locator, $field)
    {
        list($response) = $this->getAliasesWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation getAliasesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAliasesWithHttpInfo($bt_locator, $field)
    {
        $returnType = '\TeamCityClient\Model\Items';
        $request = $this->getAliasesRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAliasesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAliasesAsync($bt_locator, $field)
    {
        return $this->getAliasesAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAliasesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAliasesAsyncWithHttpInfo($bt_locator, $field)
    {
        $returnType = '\TeamCityClient\Model\Items';
        $request = $this->getAliasesRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAliases'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAliasesRequest($bt_locator, $field)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAliases'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling getAliases'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/aliases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\ArtifactDependency
     */
    public function getArtifactDep($bt_locator, $artifact_dep_locator, $fields = null)
    {
        list($response) = $this->getArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator, $fields);
        return $response;
    }

    /**
     * Operation getArtifactDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->getArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepAsync($bt_locator, $artifact_dep_locator, $fields = null)
    {
        return $this->getArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->getArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getArtifactDep'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling getArtifactDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDepSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getArtifactDepSetting($bt_locator, $artifact_dep_locator, $field_name)
    {
        list($response) = $this->getArtifactDepSettingWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name);
        return $response;
    }

    /**
     * Operation getArtifactDepSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDepSettingWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDepSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepSettingAsync($bt_locator, $artifact_dep_locator, $field_name)
    {
        return $this->getArtifactDepSettingAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDepSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepSettingAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDepSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDepSettingRequest($bt_locator, $artifact_dep_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getArtifactDepSetting'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling getArtifactDepSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getArtifactDepSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDeps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\ArtifactDependencies
     */
    public function getArtifactDeps($bt_locator, $fields = null)
    {
        list($response) = $this->getArtifactDepsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getArtifactDepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\ArtifactDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDepsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependencies';
        $request = $this->getArtifactDepsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\ArtifactDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepsAsync($bt_locator, $fields = null)
    {
        return $this->getArtifactDepsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDepsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependencies';
        $request = $this->getArtifactDepsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDeps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDepsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getArtifactDeps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTypes
     *
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildTypes
     */
    public function getBuildTypes($locator = null, $fields = null)
    {
        list($response) = $this->getBuildTypesWithHttpInfo($locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTypesWithHttpInfo
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypesWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->getBuildTypesRequest($locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypesAsync
     *
     * 
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypesAsync($locator = null, $fields = null)
    {
        return $this->getBuildTypesAsyncWithHttpInfo($locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypesAsyncWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->getBuildTypesRequest($locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTypes'
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypesRequest($locator = null, $fields = null)
    {

        $resourcePath = '/app/rest/buildTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChildren
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Files
     */
    public function getChildren($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getChildrenWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getChildrenWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChildrenWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getChildrenRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChildrenAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsync($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        return $this->getChildrenAsyncWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChildrenAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsyncWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getChildrenRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChildren'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChildrenRequest($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getChildren'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getChildren, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getChildren'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/children{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChildrenAlias
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Files
     */
    public function getChildrenAlias($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getChildrenAliasWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getChildrenAliasWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChildrenAliasWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getChildrenAliasRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChildrenAliasAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAliasAsync($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        return $this->getChildrenAliasAsyncWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChildrenAliasAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAliasAsyncWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getChildrenAliasRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChildrenAlias'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChildrenAliasRequest($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getChildrenAlias'
            );
        }
        if (!preg_match("/(.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getChildrenAlias, must conform to the pattern /(.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getChildrenAlias'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContent
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $response_builder response_builder (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getContent($path, $bt_locator, $response_builder = null, $resolve_parameters = null)
    {
        $this->getContentWithHttpInfo($path, $bt_locator, $response_builder, $resolve_parameters);
    }

    /**
     * Operation getContentWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $response_builder (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContentWithHttpInfo($path, $bt_locator, $response_builder = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getContentRequest($path, $bt_locator, $response_builder, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getContentAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $response_builder (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAsync($path, $bt_locator, $response_builder = null, $resolve_parameters = null)
    {
        return $this->getContentAsyncWithHttpInfo($path, $bt_locator, $response_builder, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $response_builder (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAsyncWithHttpInfo($path, $bt_locator, $response_builder = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getContentRequest($path, $bt_locator, $response_builder, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContent'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $response_builder (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getContentRequest($path, $bt_locator, $response_builder = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getContent'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getContent, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getContent'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/content{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($response_builder !== null) {
            $queryParams['responseBuilder'] = ObjectSerializer::toQueryValue($response_builder);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContentAlias
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getContentAlias($path, $bt_locator, $resolve_parameters = null)
    {
        $this->getContentAliasWithHttpInfo($path, $bt_locator, $resolve_parameters);
    }

    /**
     * Operation getContentAliasWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContentAliasWithHttpInfo($path, $bt_locator, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getContentAliasRequest($path, $bt_locator, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getContentAliasAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAliasAsync($path, $bt_locator, $resolve_parameters = null)
    {
        return $this->getContentAliasAsyncWithHttpInfo($path, $bt_locator, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContentAliasAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAliasAsyncWithHttpInfo($path, $bt_locator, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getContentAliasRequest($path, $bt_locator, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContentAlias'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getContentAliasRequest($path, $bt_locator, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getContentAlias'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getContentAlias, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getContentAlias'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/files{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentVcsInstances
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootInstances
     */
    public function getCurrentVcsInstances($bt_locator, $fields = null)
    {
        list($response) = $this->getCurrentVcsInstancesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getCurrentVcsInstancesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootInstances, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentVcsInstancesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootInstances';
        $request = $this->getCurrentVcsInstancesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootInstances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrentVcsInstancesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVcsInstancesAsync($bt_locator, $fields = null)
    {
        return $this->getCurrentVcsInstancesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentVcsInstancesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVcsInstancesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootInstances';
        $request = $this->getCurrentVcsInstancesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentVcsInstances'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentVcsInstancesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getCurrentVcsInstances'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcsRootInstances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentVcsInstancesObsolete
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootInstances
     */
    public function getCurrentVcsInstancesObsolete($bt_locator, $fields = null)
    {
        list($response) = $this->getCurrentVcsInstancesObsoleteWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getCurrentVcsInstancesObsoleteWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootInstances, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentVcsInstancesObsoleteWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootInstances';
        $request = $this->getCurrentVcsInstancesObsoleteRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootInstances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrentVcsInstancesObsoleteAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVcsInstancesObsoleteAsync($bt_locator, $fields = null)
    {
        return $this->getCurrentVcsInstancesObsoleteAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentVcsInstancesObsoleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVcsInstancesObsoleteAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootInstances';
        $request = $this->getCurrentVcsInstancesObsoleteRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentVcsInstancesObsolete'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentVcsInstancesObsoleteRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getCurrentVcsInstancesObsolete'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExampleNewProjectDescription
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\NewBuildTypeDescription
     */
    public function getExampleNewProjectDescription($bt_locator)
    {
        list($response) = $this->getExampleNewProjectDescriptionWithHttpInfo($bt_locator);
        return $response;
    }

    /**
     * Operation getExampleNewProjectDescriptionWithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\NewBuildTypeDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExampleNewProjectDescriptionWithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\NewBuildTypeDescription';
        $request = $this->getExampleNewProjectDescriptionRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\NewBuildTypeDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExampleNewProjectDescriptionAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExampleNewProjectDescriptionAsync($bt_locator)
    {
        return $this->getExampleNewProjectDescriptionAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExampleNewProjectDescriptionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExampleNewProjectDescriptionAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\NewBuildTypeDescription';
        $request = $this->getExampleNewProjectDescriptionRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExampleNewProjectDescription'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExampleNewProjectDescriptionRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getExampleNewProjectDescription'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/example/newBuildTypeDescription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExampleNewProjectDescriptionCompatibilityVersion1
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\NewBuildTypeDescription
     */
    public function getExampleNewProjectDescriptionCompatibilityVersion1($bt_locator)
    {
        list($response) = $this->getExampleNewProjectDescriptionCompatibilityVersion1WithHttpInfo($bt_locator);
        return $response;
    }

    /**
     * Operation getExampleNewProjectDescriptionCompatibilityVersion1WithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\NewBuildTypeDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExampleNewProjectDescriptionCompatibilityVersion1WithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\NewBuildTypeDescription';
        $request = $this->getExampleNewProjectDescriptionCompatibilityVersion1Request($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\NewBuildTypeDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExampleNewProjectDescriptionCompatibilityVersion1Async
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExampleNewProjectDescriptionCompatibilityVersion1Async($bt_locator)
    {
        return $this->getExampleNewProjectDescriptionCompatibilityVersion1AsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExampleNewProjectDescriptionCompatibilityVersion1AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExampleNewProjectDescriptionCompatibilityVersion1AsyncWithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\NewBuildTypeDescription';
        $request = $this->getExampleNewProjectDescriptionCompatibilityVersion1Request($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExampleNewProjectDescriptionCompatibilityVersion1'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExampleNewProjectDescriptionCompatibilityVersion1Request($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getExampleNewProjectDescriptionCompatibilityVersion1'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/newBuildTypeDescription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeature
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Feature
     */
    public function getFeature($bt_locator, $feature_id, $fields = null)
    {
        list($response) = $this->getFeatureWithHttpInfo($bt_locator, $feature_id, $fields);
        return $response;
    }

    /**
     * Operation getFeatureWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->getFeatureRequest($bt_locator, $feature_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureAsync($bt_locator, $feature_id, $fields = null)
    {
        return $this->getFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->getFeatureRequest($bt_locator, $feature_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureRequest($bt_locator, $feature_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureParameter
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $parameter_name parameter_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getFeatureParameter($bt_locator, $feature_id, $parameter_name)
    {
        list($response) = $this->getFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name);
        return $response;
    }

    /**
     * Operation getFeatureParameterWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getFeatureParameterRequest($bt_locator, $feature_id, $parameter_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureParameterAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureParameterAsync($bt_locator, $feature_id, $parameter_name)
    {
        return $this->getFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getFeatureParameterRequest($bt_locator, $feature_id, $parameter_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureParameterRequest($bt_locator, $feature_id, $parameter_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFeatureParameter'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getFeatureParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling getFeatureParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function getFeatureParameters($bt_locator, $feature_id, $fields = null)
    {
        list($response) = $this->getFeatureParametersWithHttpInfo($bt_locator, $feature_id, $fields);
        return $response;
    }

    /**
     * Operation getFeatureParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureParametersWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getFeatureParametersRequest($bt_locator, $feature_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureParametersAsync($bt_locator, $feature_id, $fields = null)
    {
        return $this->getFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getFeatureParametersRequest($bt_locator, $feature_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureParametersRequest($bt_locator, $feature_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFeatureParameters'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getFeatureParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $name name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getFeatureSetting($bt_locator, $feature_id, $name)
    {
        list($response) = $this->getFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name);
        return $response;
    }

    /**
     * Operation getFeatureSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name)
    {
        $returnType = 'string';
        $request = $this->getFeatureSettingRequest($bt_locator, $feature_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureSettingAsync($bt_locator, $feature_id, $name)
    {
        return $this->getFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name)
    {
        $returnType = 'string';
        $request = $this->getFeatureSettingRequest($bt_locator, $feature_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureSettingRequest($bt_locator, $feature_id, $name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFeatureSetting'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getFeatureSetting'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFeatureSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatures
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Features
     */
    public function getFeatures($bt_locator, $fields = null)
    {
        list($response) = $this->getFeaturesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getFeaturesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Features, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeaturesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Features';
        $request = $this->getFeaturesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Features',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeaturesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesAsync($bt_locator, $fields = null)
    {
        return $this->getFeaturesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeaturesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeaturesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Features';
        $request = $this->getFeaturesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatures'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeaturesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFeatures'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvestigations
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Investigations
     */
    public function getInvestigations($bt_locator, $fields = null)
    {
        list($response) = $this->getInvestigationsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getInvestigationsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Investigations, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvestigationsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Investigations';
        $request = $this->getInvestigationsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Investigations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvestigationsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvestigationsAsync($bt_locator, $fields = null)
    {
        return $this->getInvestigationsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvestigationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvestigationsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Investigations';
        $request = $this->getInvestigationsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvestigations'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvestigationsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getInvestigations'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/investigations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMetadata
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\\SplFileObject
     */
    public function getMetadata($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getMetadataWithHttpInfo($path, $bt_locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getMetadataWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\\SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMetadataWithHttpInfo($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\\SplFileObject';
        $request = $this->getMetadataRequest($path, $bt_locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMetadataAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetadataAsync($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        return $this->getMetadataAsyncWithHttpInfo($path, $bt_locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMetadataAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetadataAsyncWithHttpInfo($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\\SplFileObject';
        $request = $this->getMetadataRequest($path, $bt_locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMetadata'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMetadataRequest($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getMetadata'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getMetadata, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getMetadata'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/metadata{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameter
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function getParameter($name, $bt_locator, $fields = null)
    {
        list($response) = $this->getParameterWithHttpInfo($name, $bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getParameterWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameterWithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->getParameterRequest($name, $bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameterAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterAsync($name, $bt_locator, $fields = null)
    {
        return $this->getParameterAsyncWithHttpInfo($name, $bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterAsyncWithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->getParameterRequest($name, $bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameter'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameterRequest($name, $bt_locator, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameter'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameterType
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Type
     */
    public function getParameterType($name, $bt_locator)
    {
        list($response) = $this->getParameterTypeWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getParameterTypeWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Type, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameterTypeWithHttpInfo($name, $bt_locator)
    {
        $returnType = '\TeamCityClient\Model\Type';
        $request = $this->getParameterTypeRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Type',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameterTypeAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterTypeAsync($name, $bt_locator)
    {
        return $this->getParameterTypeAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameterTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterTypeAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = '\TeamCityClient\Model\Type';
        $request = $this->getParameterTypeRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameterType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameterTypeRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameterType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameterType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameterTypeRawValue
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getParameterTypeRawValue($name, $bt_locator)
    {
        list($response) = $this->getParameterTypeRawValueWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getParameterTypeRawValueWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameterTypeRawValueWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterTypeRawValueRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameterTypeRawValueAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterTypeRawValueAsync($name, $bt_locator)
    {
        return $this->getParameterTypeRawValueAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameterTypeRawValueAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterTypeRawValueAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterTypeRawValueRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameterTypeRawValue'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameterTypeRawValueRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameterTypeRawValue'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameterTypeRawValue'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type/rawValue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameterValueLong
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getParameterValueLong($name, $bt_locator)
    {
        list($response) = $this->getParameterValueLongWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getParameterValueLongWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameterValueLongWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterValueLongRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameterValueLongAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterValueLongAsync($name, $bt_locator)
    {
        return $this->getParameterValueLongAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameterValueLongAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterValueLongAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterValueLongRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameterValueLong'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameterValueLongRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameterValueLong'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameterValueLong'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameterValueLong_0
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getParameterValueLong_0($name, $bt_locator)
    {
        list($response) = $this->getParameterValueLong_0WithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getParameterValueLong_0WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameterValueLong_0WithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterValueLong_0Request($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameterValueLong_0Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterValueLong_0Async($name, $bt_locator)
    {
        return $this->getParameterValueLong_0AsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameterValueLong_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameterValueLong_0AsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getParameterValueLong_0Request($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameterValueLong_0'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameterValueLong_0Request($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameterValueLong_0'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameterValueLong_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameter_0
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function getParameter_0($name, $bt_locator, $fields = null)
    {
        list($response) = $this->getParameter_0WithHttpInfo($name, $bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getParameter_0WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameter_0WithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->getParameter_0Request($name, $bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameter_0Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameter_0Async($name, $bt_locator, $fields = null)
    {
        return $this->getParameter_0AsyncWithHttpInfo($name, $bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameter_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameter_0AsyncWithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->getParameter_0Request($name, $bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameter_0'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameter_0Request($name, $bt_locator, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getParameter_0'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameter_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function getParameters($bt_locator, $locator = null, $fields = null)
    {
        list($response) = $this->getParametersWithHttpInfo($bt_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation getParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParametersWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getParametersRequest($bt_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParametersAsync($bt_locator, $locator = null, $fields = null)
    {
        return $this->getParametersAsyncWithHttpInfo($bt_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParametersAsyncWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getParametersRequest($bt_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParametersRequest($bt_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParameters_0
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function getParameters_0($bt_locator, $locator = null, $fields = null)
    {
        list($response) = $this->getParameters_0WithHttpInfo($bt_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation getParameters_0WithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParameters_0WithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getParameters_0Request($bt_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParameters_0Async
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameters_0Async($bt_locator, $locator = null, $fields = null)
    {
        return $this->getParameters_0AsyncWithHttpInfo($bt_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParameters_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParameters_0AsyncWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getParameters_0Request($bt_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParameters_0'
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParameters_0Request($bt_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getParameters_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRequirementSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getRequirementSetting($bt_locator, $agent_requirement_locator, $field_name)
    {
        list($response) = $this->getRequirementSettingWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name);
        return $response;
    }

    /**
     * Operation getRequirementSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRequirementSettingWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRequirementSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRequirementSettingAsync($bt_locator, $agent_requirement_locator, $field_name)
    {
        return $this->getRequirementSettingAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRequirementSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRequirementSettingAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRequirementSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRequirementSettingRequest($bt_locator, $agent_requirement_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getRequirementSetting'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling getRequirementSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getRequirementSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoot
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Files
     */
    public function getRoot($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getRootWithHttpInfo($bt_locator, $base_path, $locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getRootWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRootWithHttpInfo($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getRootRequest($bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRootAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootAsync($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        return $this->getRootAsyncWithHttpInfo($bt_locator, $base_path, $locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRootAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootAsyncWithHttpInfo($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\TeamCityClient\Model\Files';
        $request = $this->getRootRequest($bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoot'
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRootRequest($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getRoot'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSettingsFile
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getSettingsFile($bt_locator)
    {
        list($response) = $this->getSettingsFileWithHttpInfo($bt_locator);
        return $response;
    }

    /**
     * Operation getSettingsFileWithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSettingsFileWithHttpInfo($bt_locator)
    {
        $returnType = 'string';
        $request = $this->getSettingsFileRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSettingsFileAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSettingsFileAsync($bt_locator)
    {
        return $this->getSettingsFileAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSettingsFileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSettingsFileAsyncWithHttpInfo($bt_locator)
    {
        $returnType = 'string';
        $request = $this->getSettingsFileRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSettingsFile'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSettingsFileRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getSettingsFile'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settingsFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSnapshotDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\SnapshotDependency
     */
    public function getSnapshotDep($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        list($response) = $this->getSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields);
        return $response;
    }

    /**
     * Operation getSnapshotDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->getSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSnapshotDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDepAsync($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        return $this->getSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSnapshotDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->getSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSnapshotDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getSnapshotDep'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling getSnapshotDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSnapshotDeps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\SnapshotDependencies
     */
    public function getSnapshotDeps($bt_locator, $fields = null)
    {
        list($response) = $this->getSnapshotDepsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getSnapshotDepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\SnapshotDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSnapshotDepsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependencies';
        $request = $this->getSnapshotDepsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\SnapshotDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSnapshotDepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDepsAsync($bt_locator, $fields = null)
    {
        return $this->getSnapshotDepsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSnapshotDepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDepsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependencies';
        $request = $this->getSnapshotDepsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSnapshotDeps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSnapshotDepsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getSnapshotDeps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Step
     */
    public function getStep($bt_locator, $step_id, $fields = null)
    {
        list($response) = $this->getStepWithHttpInfo($bt_locator, $step_id, $fields);
        return $response;
    }

    /**
     * Operation getStepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStepWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->getStepRequest($bt_locator, $step_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepAsync($bt_locator, $step_id, $fields = null)
    {
        return $this->getStepAsyncWithHttpInfo($bt_locator, $step_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepAsyncWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->getStepRequest($bt_locator, $step_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStepRequest($bt_locator, $step_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStepParameter
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $parameter_name parameter_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getStepParameter($bt_locator, $step_id, $parameter_name)
    {
        list($response) = $this->getStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name);
        return $response;
    }

    /**
     * Operation getStepParameterWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getStepParameterRequest($bt_locator, $step_id, $parameter_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStepParameterAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepParameterAsync($bt_locator, $step_id, $parameter_name)
    {
        return $this->getStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStepParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getStepParameterRequest($bt_locator, $step_id, $parameter_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStepParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStepParameterRequest($bt_locator, $step_id, $parameter_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getStepParameter'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getStepParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling getStepParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStepParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function getStepParameters($bt_locator, $step_id, $fields = null)
    {
        list($response) = $this->getStepParametersWithHttpInfo($bt_locator, $step_id, $fields);
        return $response;
    }

    /**
     * Operation getStepParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStepParametersWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getStepParametersRequest($bt_locator, $step_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStepParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepParametersAsync($bt_locator, $step_id, $fields = null)
    {
        return $this->getStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStepParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->getStepParametersRequest($bt_locator, $step_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStepParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStepParametersRequest($bt_locator, $step_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getStepParameters'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getStepParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStepSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getStepSetting($bt_locator, $step_id, $field_name)
    {
        list($response) = $this->getStepSettingWithHttpInfo($bt_locator, $step_id, $field_name);
        return $response;
    }

    /**
     * Operation getStepSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStepSettingWithHttpInfo($bt_locator, $step_id, $field_name)
    {
        $returnType = 'string';
        $request = $this->getStepSettingRequest($bt_locator, $step_id, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStepSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepSettingAsync($bt_locator, $step_id, $field_name)
    {
        return $this->getStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStepSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name)
    {
        $returnType = 'string';
        $request = $this->getStepSettingRequest($bt_locator, $step_id, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStepSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStepSettingRequest($bt_locator, $step_id, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getStepSetting'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getStepSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getStepSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSteps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Steps
     */
    public function getSteps($bt_locator, $fields = null)
    {
        list($response) = $this->getStepsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getStepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Steps, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStepsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Steps';
        $request = $this->getStepsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Steps',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepsAsync($bt_locator, $fields = null)
    {
        return $this->getStepsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStepsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Steps';
        $request = $this->getStepsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSteps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStepsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getSteps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplate
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $template_locator template_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildType
     */
    public function getTemplate($bt_locator, $template_locator, $fields = null)
    {
        list($response) = $this->getTemplateWithHttpInfo($bt_locator, $template_locator, $fields);
        return $response;
    }

    /**
     * Operation getTemplateWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateWithHttpInfo($bt_locator, $template_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->getTemplateRequest($bt_locator, $template_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplateAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsync($bt_locator, $template_locator, $fields = null)
    {
        return $this->getTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->getTemplateRequest($bt_locator, $template_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTemplateRequest($bt_locator, $template_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTemplate'
            );
        }
        // verify the required parameter 'template_locator' is set
        if ($template_locator === null || (is_array($template_locator) && count($template_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_locator when calling getTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates/{templateLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($template_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'templateLocator' . '}',
                ObjectSerializer::toPathValue($template_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplates
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildTypes
     */
    public function getTemplates($bt_locator, $fields = null)
    {
        list($response) = $this->getTemplatesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getTemplatesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplatesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->getTemplatesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplatesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsync($bt_locator, $fields = null)
    {
        return $this->getTemplatesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplatesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->getTemplatesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTemplatesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrigger
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Trigger
     */
    public function getTrigger($bt_locator, $trigger_locator, $fields = null)
    {
        list($response) = $this->getTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields);
        return $response;
    }

    /**
     * Operation getTriggerWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->getTriggerRequest($bt_locator, $trigger_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriggerAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerAsync($bt_locator, $trigger_locator, $fields = null)
    {
        return $this->getTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->getTriggerRequest($bt_locator, $trigger_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriggerRequest($bt_locator, $trigger_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling getTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTriggerSetting
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getTriggerSetting($bt_locator, $trigger_locator, $field_name)
    {
        list($response) = $this->getTriggerSettingWithHttpInfo($bt_locator, $trigger_locator, $field_name);
        return $response;
    }

    /**
     * Operation getTriggerSettingWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggerSettingWithHttpInfo($bt_locator, $trigger_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getTriggerSettingRequest($bt_locator, $trigger_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriggerSettingAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerSettingAsync($bt_locator, $trigger_locator, $field_name)
    {
        return $this->getTriggerSettingAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggerSettingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerSettingAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getTriggerSettingRequest($bt_locator, $trigger_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTriggerSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriggerSettingRequest($bt_locator, $trigger_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTriggerSetting'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling getTriggerSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getTriggerSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTriggers
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Triggers
     */
    public function getTriggers($bt_locator, $fields = null)
    {
        list($response) = $this->getTriggersWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getTriggersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Triggers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggersWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Triggers';
        $request = $this->getTriggersRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Triggers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriggersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggersAsync($bt_locator, $fields = null)
    {
        return $this->getTriggersAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggersAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Triggers';
        $request = $this->getTriggersRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTriggers'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriggersRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTriggers'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVCSLabelingOptions
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsLabeling
     */
    public function getVCSLabelingOptions($bt_locator)
    {
        list($response) = $this->getVCSLabelingOptionsWithHttpInfo($bt_locator);
        return $response;
    }

    /**
     * Operation getVCSLabelingOptionsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsLabeling, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVCSLabelingOptionsWithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\VcsLabeling';
        $request = $this->getVCSLabelingOptionsRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsLabeling',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVCSLabelingOptionsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVCSLabelingOptionsAsync($bt_locator)
    {
        return $this->getVCSLabelingOptionsAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVCSLabelingOptionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVCSLabelingOptionsAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '\TeamCityClient\Model\VcsLabeling';
        $request = $this->getVCSLabelingOptionsRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVCSLabelingOptions'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVCSLabelingOptionsRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVCSLabelingOptions'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcsLabeling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRootEntries
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootEntries
     */
    public function getVcsRootEntries($bt_locator, $fields = null)
    {
        list($response) = $this->getVcsRootEntriesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getVcsRootEntriesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootEntries, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootEntriesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntries';
        $request = $this->getVcsRootEntriesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootEntries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootEntriesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntriesAsync($bt_locator, $fields = null)
    {
        return $this->getVcsRootEntriesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootEntriesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntriesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntries';
        $request = $this->getVcsRootEntriesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRootEntries'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootEntriesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRootEntries'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRootEntry
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootEntry
     */
    public function getVcsRootEntry($bt_locator, $vcs_root_locator, $fields = null)
    {
        list($response) = $this->getVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator, $fields);
        return $response;
    }

    /**
     * Operation getVcsRootEntryWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->getVcsRootEntryRequest($bt_locator, $vcs_root_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootEntryAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntryAsync($bt_locator, $vcs_root_locator, $fields = null)
    {
        return $this->getVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootEntryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->getVcsRootEntryRequest($bt_locator, $vcs_root_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRootEntry'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootEntryRequest($bt_locator, $vcs_root_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRootEntry'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling getVcsRootEntry'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRootEntryCheckoutRules
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getVcsRootEntryCheckoutRules($bt_locator, $vcs_root_locator)
    {
        list($response) = $this->getVcsRootEntryCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator);
        return $response;
    }

    /**
     * Operation getVcsRootEntryCheckoutRulesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootEntryCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = 'string';
        $request = $this->getVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootEntryCheckoutRulesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntryCheckoutRulesAsync($bt_locator, $vcs_root_locator)
    {
        return $this->getVcsRootEntryCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootEntryCheckoutRulesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootEntryCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = 'string';
        $request = $this->getVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRootEntryCheckoutRules'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRootEntryCheckoutRules'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling getVcsRootEntryCheckoutRules'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}/checkout-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getZipped
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $name name (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getZipped($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $this->getZippedWithHttpInfo($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);
    }

    /**
     * Operation getZippedWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getZippedWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getZippedRequest($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getZippedAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedAsync($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        return $this->getZippedAsyncWithHttpInfo($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getZippedAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedAsyncWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getZippedRequest($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getZipped'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getZippedRequest($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getZipped'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getZipped, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getZipped'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/archived{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAllTemplates
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  bool $inline_settings inline_settings (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeAllTemplates($bt_locator, $inline_settings = null)
    {
        $this->removeAllTemplatesWithHttpInfo($bt_locator, $inline_settings);
    }

    /**
     * Operation removeAllTemplatesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAllTemplatesWithHttpInfo($bt_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeAllTemplatesRequest($bt_locator, $inline_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeAllTemplatesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllTemplatesAsync($bt_locator, $inline_settings = null)
    {
        return $this->removeAllTemplatesAsyncWithHttpInfo($bt_locator, $inline_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAllTemplatesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllTemplatesAsyncWithHttpInfo($bt_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeAllTemplatesRequest($bt_locator, $inline_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAllTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeAllTemplatesRequest($bt_locator, $inline_settings = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling removeAllTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_settings !== null) {
            $queryParams['inlineSettings'] = ObjectSerializer::toQueryValue($inline_settings);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeTemplate
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $template_locator template_locator (required)
     * @param  bool $inline_settings inline_settings (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeTemplate($bt_locator, $template_locator, $inline_settings = null)
    {
        $this->removeTemplateWithHttpInfo($bt_locator, $template_locator, $inline_settings);
    }

    /**
     * Operation removeTemplateWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeTemplateWithHttpInfo($bt_locator, $template_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeTemplateRequest($bt_locator, $template_locator, $inline_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeTemplateAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTemplateAsync($bt_locator, $template_locator, $inline_settings = null)
    {
        return $this->removeTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $inline_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeTemplateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeTemplateRequest($bt_locator, $template_locator, $inline_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeTemplateRequest($bt_locator, $template_locator, $inline_settings = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling removeTemplate'
            );
        }
        // verify the required parameter 'template_locator' is set
        if ($template_locator === null || (is_array($template_locator) && count($template_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_locator when calling removeTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates/{templateLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_settings !== null) {
            $queryParams['inlineSettings'] = ObjectSerializer::toQueryValue($inline_settings);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($template_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'templateLocator' . '}',
                ObjectSerializer::toPathValue($template_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAgentRequirement
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\AgentRequirement
     */
    public function replaceAgentRequirement($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAgentRequirementWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAgentRequirementAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementAsync($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        return $this->replaceAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAgentRequirementAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirement';
        $request = $this->replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling replaceAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAgentRequirements
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirements $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\AgentRequirements
     */
    public function replaceAgentRequirements($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAgentRequirementsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAgentRequirementsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirements $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\AgentRequirements, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAgentRequirementsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirements';
        $request = $this->replaceAgentRequirementsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\AgentRequirements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAgentRequirementsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAgentRequirementsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\AgentRequirements';
        $request = $this->replaceAgentRequirementsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAgentRequirements'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAgentRequirementsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAgentRequirements'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceArtifactDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\ArtifactDependency
     */
    public function replaceArtifactDep($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceArtifactDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceArtifactDepWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->replaceArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceArtifactDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDepAsync($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        return $this->replaceArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceArtifactDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDepAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependency';
        $request = $this->replaceArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceArtifactDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceArtifactDepRequest($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceArtifactDep'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling replaceArtifactDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceArtifactDeps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependencies $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\ArtifactDependencies
     */
    public function replaceArtifactDeps($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceArtifactDepsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceArtifactDepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependencies $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\ArtifactDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceArtifactDepsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependencies';
        $request = $this->replaceArtifactDepsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\ArtifactDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceArtifactDepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDepsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceArtifactDepsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceArtifactDepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDepsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\ArtifactDependencies';
        $request = $this->replaceArtifactDepsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceArtifactDeps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceArtifactDepsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceArtifactDeps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceFeature
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Feature $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Feature
     */
    public function replaceFeature($bt_locator, $feature_id, $fields = null, $body = null)
    {
        list($response) = $this->replaceFeatureWithHttpInfo($bt_locator, $feature_id, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceFeatureWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceFeatureWithHttpInfo($bt_locator, $feature_id, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->replaceFeatureRequest($bt_locator, $feature_id, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceFeatureAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeatureAsync($bt_locator, $feature_id, $fields = null, $body = null)
    {
        return $this->replaceFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceFeatureAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Feature';
        $request = $this->replaceFeatureRequest($bt_locator, $feature_id, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceFeatureRequest($bt_locator, $feature_id, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling replaceFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceFeatureParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  \TeamCityClient\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function replaceFeatureParameters($bt_locator, $feature_id, $body = null, $fields = null)
    {
        list($response) = $this->replaceFeatureParametersWithHttpInfo($bt_locator, $feature_id, $body, $fields);
        return $response;
    }

    /**
     * Operation replaceFeatureParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceFeatureParametersWithHttpInfo($bt_locator, $feature_id, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->replaceFeatureParametersRequest($bt_locator, $feature_id, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceFeatureParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeatureParametersAsync($bt_locator, $feature_id, $body = null, $fields = null)
    {
        return $this->replaceFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceFeatureParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->replaceFeatureParametersRequest($bt_locator, $feature_id, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceFeatureParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceFeatureParametersRequest($bt_locator, $feature_id, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceFeatureParameters'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling replaceFeatureParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceFeatures
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Features $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Features
     */
    public function replaceFeatures($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceFeaturesWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceFeaturesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Features $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Features, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceFeaturesWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Features';
        $request = $this->replaceFeaturesRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Features',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceFeaturesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeaturesAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceFeaturesAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceFeaturesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceFeaturesAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Features';
        $request = $this->replaceFeaturesRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceFeatures'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceFeaturesRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceFeatures'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceSnapshotDep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\SnapshotDependency
     */
    public function replaceSnapshotDep($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceSnapshotDepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceSnapshotDepWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->replaceSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceSnapshotDepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDepAsync($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        return $this->replaceSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceSnapshotDepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDepAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependency';
        $request = $this->replaceSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceSnapshotDep'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceSnapshotDepRequest($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceSnapshotDep'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling replaceSnapshotDep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceSnapshotDeps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependencies $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\SnapshotDependencies
     */
    public function replaceSnapshotDeps($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceSnapshotDepsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceSnapshotDepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependencies $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\SnapshotDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceSnapshotDepsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependencies';
        $request = $this->replaceSnapshotDepsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\SnapshotDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceSnapshotDepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDepsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceSnapshotDepsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceSnapshotDepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDepsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\SnapshotDependencies';
        $request = $this->replaceSnapshotDepsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceSnapshotDeps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceSnapshotDepsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceSnapshotDeps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceStep
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Step $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Step
     */
    public function replaceStep($bt_locator, $step_id, $fields = null, $body = null)
    {
        list($response) = $this->replaceStepWithHttpInfo($bt_locator, $step_id, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceStepWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceStepWithHttpInfo($bt_locator, $step_id, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->replaceStepRequest($bt_locator, $step_id, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceStepAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepAsync($bt_locator, $step_id, $fields = null, $body = null)
    {
        return $this->replaceStepAsyncWithHttpInfo($bt_locator, $step_id, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceStepAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepAsyncWithHttpInfo($bt_locator, $step_id, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Step';
        $request = $this->replaceStepRequest($bt_locator, $step_id, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceStepRequest($bt_locator, $step_id, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling replaceStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceStepParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  \TeamCityClient\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function replaceStepParameters($bt_locator, $step_id, $body = null, $fields = null)
    {
        list($response) = $this->replaceStepParametersWithHttpInfo($bt_locator, $step_id, $body, $fields);
        return $response;
    }

    /**
     * Operation replaceStepParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceStepParametersWithHttpInfo($bt_locator, $step_id, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->replaceStepParametersRequest($bt_locator, $step_id, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceStepParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepParametersAsync($bt_locator, $step_id, $body = null, $fields = null)
    {
        return $this->replaceStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceStepParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->replaceStepParametersRequest($bt_locator, $step_id, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceStepParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceStepParametersRequest($bt_locator, $step_id, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceStepParameters'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling replaceStepParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceSteps
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Steps $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Steps
     */
    public function replaceSteps($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceStepsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceStepsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Steps $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Steps, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceStepsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Steps';
        $request = $this->replaceStepsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Steps',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceStepsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceStepsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceStepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStepsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Steps';
        $request = $this->replaceStepsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceSteps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceStepsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceSteps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceTrigger
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Trigger
     */
    public function replaceTrigger($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceTriggerWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->replaceTriggerRequest($bt_locator, $trigger_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceTriggerAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggerAsync($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        return $this->replaceTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceTriggerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Trigger';
        $request = $this->replaceTriggerRequest($bt_locator, $trigger_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceTriggerRequest($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling replaceTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceTriggers
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \TeamCityClient\Model\Triggers $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Triggers
     */
    public function replaceTriggers($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceTriggersWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceTriggersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Triggers $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Triggers, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceTriggersWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Triggers';
        $request = $this->replaceTriggersRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Triggers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceTriggersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggersAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceTriggersAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceTriggersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggersAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Triggers';
        $request = $this->replaceTriggersRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceTriggers'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \TeamCityClient\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceTriggersRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceTriggers'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceVcsRootEntries
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntries $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootEntries
     */
    public function replaceVcsRootEntries($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->replaceVcsRootEntriesWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation replaceVcsRootEntriesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootEntries, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceVcsRootEntriesWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntries';
        $request = $this->replaceVcsRootEntriesRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootEntries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceVcsRootEntriesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceVcsRootEntriesAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->replaceVcsRootEntriesAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceVcsRootEntriesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceVcsRootEntriesAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntries';
        $request = $this->replaceVcsRootEntriesRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceVcsRootEntries'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceVcsRootEntriesRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceVcsRootEntries'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBranches
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Branches
     */
    public function serveBranches($bt_locator, $locator = null, $fields = null)
    {
        list($response) = $this->serveBranchesWithHttpInfo($bt_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation serveBranchesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Branches, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBranchesWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Branches';
        $request = $this->serveBranchesRequest($bt_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Branches',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBranchesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBranchesAsync($bt_locator, $locator = null, $fields = null)
    {
        return $this->serveBranchesAsyncWithHttpInfo($bt_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBranchesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBranchesAsyncWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Branches';
        $request = $this->serveBranchesRequest($bt_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBranches'
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBranchesRequest($bt_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBranches'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuildField
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $build_locator build_locator (required)
     * @param  string $field field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function serveBuildField($bt_locator, $build_locator, $field)
    {
        list($response) = $this->serveBuildFieldWithHttpInfo($bt_locator, $build_locator, $field);
        return $response;
    }

    /**
     * Operation serveBuildFieldWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildFieldWithHttpInfo($bt_locator, $build_locator, $field)
    {
        $returnType = 'string';
        $request = $this->serveBuildFieldRequest($bt_locator, $build_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildFieldAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildFieldAsync($bt_locator, $build_locator, $field)
    {
        return $this->serveBuildFieldAsyncWithHttpInfo($bt_locator, $build_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildFieldAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildFieldAsyncWithHttpInfo($bt_locator, $build_locator, $field)
    {
        $returnType = 'string';
        $request = $this->serveBuildFieldRequest($bt_locator, $build_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuildField'
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildFieldRequest($bt_locator, $build_locator, $field)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuildField'
            );
        }
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling serveBuildField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling serveBuildField'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/builds/{buildLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuildTypeBuildsTags
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Tags
     */
    public function serveBuildTypeBuildsTags($bt_locator, $field)
    {
        list($response) = $this->serveBuildTypeBuildsTagsWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation serveBuildTypeBuildsTagsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Tags, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildTypeBuildsTagsWithHttpInfo($bt_locator, $field)
    {
        $returnType = '\TeamCityClient\Model\Tags';
        $request = $this->serveBuildTypeBuildsTagsRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Tags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildTypeBuildsTagsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeBuildsTagsAsync($bt_locator, $field)
    {
        return $this->serveBuildTypeBuildsTagsAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildTypeBuildsTagsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeBuildsTagsAsyncWithHttpInfo($bt_locator, $field)
    {
        $returnType = '\TeamCityClient\Model\Tags';
        $request = $this->serveBuildTypeBuildsTagsRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuildTypeBuildsTags'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildTypeBuildsTagsRequest($bt_locator, $field)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuildTypeBuildsTags'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling serveBuildTypeBuildsTags'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/buildTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuildTypeField
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function serveBuildTypeField($bt_locator, $field)
    {
        list($response) = $this->serveBuildTypeFieldWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation serveBuildTypeFieldWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildTypeFieldWithHttpInfo($bt_locator, $field)
    {
        $returnType = 'string';
        $request = $this->serveBuildTypeFieldRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildTypeFieldAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeFieldAsync($bt_locator, $field)
    {
        return $this->serveBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildTypeFieldAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field)
    {
        $returnType = 'string';
        $request = $this->serveBuildTypeFieldRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuildTypeField'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildTypeFieldRequest($bt_locator, $field)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuildTypeField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling serveBuildTypeField'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuildTypeXML
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildType
     */
    public function serveBuildTypeXML($bt_locator, $fields = null)
    {
        list($response) = $this->serveBuildTypeXMLWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation serveBuildTypeXMLWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildTypeXMLWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->serveBuildTypeXMLRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildTypeXMLAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeXMLAsync($bt_locator, $fields = null)
    {
        return $this->serveBuildTypeXMLAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildTypeXMLAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildTypeXMLAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildType';
        $request = $this->serveBuildTypeXMLRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuildTypeXML'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildTypeXMLRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuildTypeXML'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuildWithProject
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Build
     */
    public function serveBuildWithProject($bt_locator, $build_locator, $fields = null)
    {
        list($response) = $this->serveBuildWithProjectWithHttpInfo($bt_locator, $build_locator, $fields);
        return $response;
    }

    /**
     * Operation serveBuildWithProjectWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Build, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildWithProjectWithHttpInfo($bt_locator, $build_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Build';
        $request = $this->serveBuildWithProjectRequest($bt_locator, $build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Build',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildWithProjectAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildWithProjectAsync($bt_locator, $build_locator, $fields = null)
    {
        return $this->serveBuildWithProjectAsyncWithHttpInfo($bt_locator, $build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildWithProjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildWithProjectAsyncWithHttpInfo($bt_locator, $build_locator, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Build';
        $request = $this->serveBuildWithProjectRequest($bt_locator, $build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuildWithProject'
     *
     * @param  string $bt_locator (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildWithProjectRequest($bt_locator, $build_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuildWithProject'
            );
        }
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling serveBuildWithProject'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/builds/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation serveBuilds
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $status status (optional)
     * @param  string $triggered_by_user triggered_by_user (optional)
     * @param  bool $include_personal include_personal (optional)
     * @param  bool $include_canceled include_canceled (optional)
     * @param  bool $only_pinned only_pinned (optional)
     * @param  string[] $tag tag (optional)
     * @param  string $agent_name agent_name (optional)
     * @param  string $since_build since_build (optional)
     * @param  string $since_date since_date (optional)
     * @param  int $start start (optional)
     * @param  int $count count (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Builds
     */
    public function serveBuilds($bt_locator, $status = null, $triggered_by_user = null, $include_personal = null, $include_canceled = null, $only_pinned = null, $tag = null, $agent_name = null, $since_build = null, $since_date = null, $start = null, $count = null, $locator = null, $fields = null)
    {
        list($response) = $this->serveBuildsWithHttpInfo($bt_locator, $status, $triggered_by_user, $include_personal, $include_canceled, $only_pinned, $tag, $agent_name, $since_build, $since_date, $start, $count, $locator, $fields);
        return $response;
    }

    /**
     * Operation serveBuildsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $status (optional)
     * @param  string $triggered_by_user (optional)
     * @param  bool $include_personal (optional)
     * @param  bool $include_canceled (optional)
     * @param  bool $only_pinned (optional)
     * @param  string[] $tag (optional)
     * @param  string $agent_name (optional)
     * @param  string $since_build (optional)
     * @param  string $since_date (optional)
     * @param  int $start (optional)
     * @param  int $count (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Builds, HTTP status code, HTTP response headers (array of strings)
     */
    public function serveBuildsWithHttpInfo($bt_locator, $status = null, $triggered_by_user = null, $include_personal = null, $include_canceled = null, $only_pinned = null, $tag = null, $agent_name = null, $since_build = null, $since_date = null, $start = null, $count = null, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Builds';
        $request = $this->serveBuildsRequest($bt_locator, $status, $triggered_by_user, $include_personal, $include_canceled, $only_pinned, $tag, $agent_name, $since_build, $since_date, $start, $count, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Builds',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation serveBuildsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $status (optional)
     * @param  string $triggered_by_user (optional)
     * @param  bool $include_personal (optional)
     * @param  bool $include_canceled (optional)
     * @param  bool $only_pinned (optional)
     * @param  string[] $tag (optional)
     * @param  string $agent_name (optional)
     * @param  string $since_build (optional)
     * @param  string $since_date (optional)
     * @param  int $start (optional)
     * @param  int $count (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildsAsync($bt_locator, $status = null, $triggered_by_user = null, $include_personal = null, $include_canceled = null, $only_pinned = null, $tag = null, $agent_name = null, $since_build = null, $since_date = null, $start = null, $count = null, $locator = null, $fields = null)
    {
        return $this->serveBuildsAsyncWithHttpInfo($bt_locator, $status, $triggered_by_user, $include_personal, $include_canceled, $only_pinned, $tag, $agent_name, $since_build, $since_date, $start, $count, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation serveBuildsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $status (optional)
     * @param  string $triggered_by_user (optional)
     * @param  bool $include_personal (optional)
     * @param  bool $include_canceled (optional)
     * @param  bool $only_pinned (optional)
     * @param  string[] $tag (optional)
     * @param  string $agent_name (optional)
     * @param  string $since_build (optional)
     * @param  string $since_date (optional)
     * @param  int $start (optional)
     * @param  int $count (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function serveBuildsAsyncWithHttpInfo($bt_locator, $status = null, $triggered_by_user = null, $include_personal = null, $include_canceled = null, $only_pinned = null, $tag = null, $agent_name = null, $since_build = null, $since_date = null, $start = null, $count = null, $locator = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Builds';
        $request = $this->serveBuildsRequest($bt_locator, $status, $triggered_by_user, $include_personal, $include_canceled, $only_pinned, $tag, $agent_name, $since_build, $since_date, $start, $count, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'serveBuilds'
     *
     * @param  string $bt_locator (required)
     * @param  string $status (optional)
     * @param  string $triggered_by_user (optional)
     * @param  bool $include_personal (optional)
     * @param  bool $include_canceled (optional)
     * @param  bool $only_pinned (optional)
     * @param  string[] $tag (optional)
     * @param  string $agent_name (optional)
     * @param  string $since_build (optional)
     * @param  string $since_date (optional)
     * @param  int $start (optional)
     * @param  int $count (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function serveBuildsRequest($bt_locator, $status = null, $triggered_by_user = null, $include_personal = null, $include_canceled = null, $only_pinned = null, $tag = null, $agent_name = null, $since_build = null, $since_date = null, $start = null, $count = null, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling serveBuilds'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($triggered_by_user !== null) {
            $queryParams['triggeredByUser'] = ObjectSerializer::toQueryValue($triggered_by_user);
        }
        // query params
        if ($include_personal !== null) {
            $queryParams['includePersonal'] = ObjectSerializer::toQueryValue($include_personal);
        }
        // query params
        if ($include_canceled !== null) {
            $queryParams['includeCanceled'] = ObjectSerializer::toQueryValue($include_canceled);
        }
        // query params
        if ($only_pinned !== null) {
            $queryParams['onlyPinned'] = ObjectSerializer::toQueryValue($only_pinned);
        }
        // query params
        if (is_array($tag)) {
            $queryParams['tag'] = $tag;
        } else
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }
        // query params
        if ($agent_name !== null) {
            $queryParams['agentName'] = ObjectSerializer::toQueryValue($agent_name);
        }
        // query params
        if ($since_build !== null) {
            $queryParams['sinceBuild'] = ObjectSerializer::toQueryValue($since_build);
        }
        // query params
        if ($since_date !== null) {
            $queryParams['sinceDate'] = ObjectSerializer::toQueryValue($since_date);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildTypeField
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildTypeField($bt_locator, $field, $body = null)
    {
        list($response) = $this->setBuildTypeFieldWithHttpInfo($bt_locator, $field, $body);
        return $response;
    }

    /**
     * Operation setBuildTypeFieldWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildTypeFieldWithHttpInfo($bt_locator, $field, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildTypeFieldRequest($bt_locator, $field, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildTypeFieldAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeFieldAsync($bt_locator, $field, $body = null)
    {
        return $this->setBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildTypeFieldAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildTypeFieldRequest($bt_locator, $field, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildTypeField'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildTypeFieldRequest($bt_locator, $field, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setBuildTypeField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling setBuildTypeField'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameter
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function setParameter($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParameterWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParameterWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameterWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameterRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameterAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->setParameterAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameterRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameter'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameterRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameterType
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Type $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Type
     */
    public function setParameterType($name, $bt_locator, $body = null)
    {
        list($response) = $this->setParameterTypeWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation setParameterTypeWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Type $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Type, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameterTypeWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Type';
        $request = $this->setParameterTypeRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Type',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameterTypeAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterTypeAsync($name, $bt_locator, $body = null)
    {
        return $this->setParameterTypeAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameterTypeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterTypeAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = '\TeamCityClient\Model\Type';
        $request = $this->setParameterTypeRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameterType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameterTypeRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameterType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameterType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameterTypeRawValue
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setParameterTypeRawValue($name, $bt_locator, $body = null)
    {
        list($response) = $this->setParameterTypeRawValueWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation setParameterTypeRawValueWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameterTypeRawValueWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterTypeRawValueRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameterTypeRawValueAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterTypeRawValueAsync($name, $bt_locator, $body = null)
    {
        return $this->setParameterTypeRawValueAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameterTypeRawValueAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterTypeRawValueAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterTypeRawValueRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameterTypeRawValue'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameterTypeRawValueRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameterTypeRawValue'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameterTypeRawValue'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type/rawValue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameterValueLong
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setParameterValueLong($name, $bt_locator, $body = null)
    {
        list($response) = $this->setParameterValueLongWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation setParameterValueLongWithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameterValueLongWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterValueLongRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameterValueLongAsync
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterValueLongAsync($name, $bt_locator, $body = null)
    {
        return $this->setParameterValueLongAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameterValueLongAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterValueLongAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterValueLongRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameterValueLong'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameterValueLongRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameterValueLong'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameterValueLong'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameterValueLong_0
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setParameterValueLong_0($name, $bt_locator, $body = null)
    {
        list($response) = $this->setParameterValueLong_0WithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation setParameterValueLong_0WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameterValueLong_0WithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterValueLong_0Request($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameterValueLong_0Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterValueLong_0Async($name, $bt_locator, $body = null)
    {
        return $this->setParameterValueLong_0AsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameterValueLong_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameterValueLong_0AsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setParameterValueLong_0Request($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameterValueLong_0'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameterValueLong_0Request($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameterValueLong_0'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameterValueLong_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameter_0
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function setParameter_0($name, $bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParameter_0WithHttpInfo($name, $bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParameter_0WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameter_0WithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_0Request($name, $bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameter_0Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_0Async($name, $bt_locator, $body = null, $fields = null)
    {
        return $this->setParameter_0AsyncWithHttpInfo($name, $bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameter_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_0AsyncWithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_0Request($name, $bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameter_0'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameter_0Request($name, $bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameter_0'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameter_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameter_1
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function setParameter_1($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParameter_1WithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParameter_1WithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameter_1WithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_1Request($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameter_1Async
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_1Async($bt_locator, $body = null, $fields = null)
    {
        return $this->setParameter_1AsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameter_1AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_1AsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_1Request($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameter_1'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameter_1Request($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameter_1'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameter_2
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Property
     */
    public function setParameter_2($name, $bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParameter_2WithHttpInfo($name, $bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParameter_2WithHttpInfo
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameter_2WithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_2Request($name, $bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameter_2Async
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_2Async($name, $bt_locator, $body = null, $fields = null)
    {
        return $this->setParameter_2AsyncWithHttpInfo($name, $bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameter_2AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameter_2AsyncWithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Property';
        $request = $this->setParameter_2Request($name, $bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameter_2'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameter_2Request($name, $bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setParameter_2'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameter_2'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameters
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function setParameters($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParametersWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParametersWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParametersWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->setParametersRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParametersAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParametersAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->setParametersAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParametersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParametersAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->setParametersRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameters'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParametersRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setParameters_0
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\Properties
     */
    public function setParameters_0($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->setParameters_0WithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setParameters_0WithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function setParameters_0WithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->setParameters_0Request($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setParameters_0Async
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameters_0Async($bt_locator, $body = null, $fields = null)
    {
        return $this->setParameters_0AsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setParameters_0AsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setParameters_0AsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\Properties';
        $request = $this->setParameters_0Request($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setParameters_0'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setParameters_0Request($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setParameters_0'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setTemplates
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\BuildTypes $body body (optional)
     * @param  bool $optimize_settings optimize_settings (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\BuildTypes
     */
    public function setTemplates($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        list($response) = $this->setTemplatesWithHttpInfo($bt_locator, $body, $optimize_settings, $fields);
        return $response;
    }

    /**
     * Operation setTemplatesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function setTemplatesWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->setTemplatesRequest($bt_locator, $body, $optimize_settings, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setTemplatesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setTemplatesAsync($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        return $this->setTemplatesAsyncWithHttpInfo($bt_locator, $body, $optimize_settings, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setTemplatesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setTemplatesAsyncWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\BuildTypes';
        $request = $this->setTemplatesRequest($bt_locator, $body, $optimize_settings, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setTemplatesRequest($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($optimize_settings !== null) {
            $queryParams['optimizeSettings'] = ObjectSerializer::toQueryValue($optimize_settings);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setVCSLabelingOptions
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \TeamCityClient\Model\VcsLabeling $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsLabeling
     */
    public function setVCSLabelingOptions($bt_locator, $body = null)
    {
        list($response) = $this->setVCSLabelingOptionsWithHttpInfo($bt_locator, $body);
        return $response;
    }

    /**
     * Operation setVCSLabelingOptionsWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsLabeling $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsLabeling, HTTP status code, HTTP response headers (array of strings)
     */
    public function setVCSLabelingOptionsWithHttpInfo($bt_locator, $body = null)
    {
        $returnType = '\TeamCityClient\Model\VcsLabeling';
        $request = $this->setVCSLabelingOptionsRequest($bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsLabeling',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setVCSLabelingOptionsAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsLabeling $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVCSLabelingOptionsAsync($bt_locator, $body = null)
    {
        return $this->setVCSLabelingOptionsAsyncWithHttpInfo($bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setVCSLabelingOptionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsLabeling $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVCSLabelingOptionsAsyncWithHttpInfo($bt_locator, $body = null)
    {
        $returnType = '\TeamCityClient\Model\VcsLabeling';
        $request = $this->setVCSLabelingOptionsRequest($bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setVCSLabelingOptions'
     *
     * @param  string $bt_locator (required)
     * @param  \TeamCityClient\Model\VcsLabeling $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setVCSLabelingOptionsRequest($bt_locator, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setVCSLabelingOptions'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcsLabeling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVcsRootEntry
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \TeamCityClient\Model\VcsRootEntry
     */
    public function updateVcsRootEntry($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        list($response) = $this->updateVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation updateVcsRootEntryWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \TeamCityClient\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVcsRootEntryWithHttpInfo($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->updateVcsRootEntryRequest($bt_locator, $vcs_root_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\TeamCityClient\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVcsRootEntryAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVcsRootEntryAsync($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        return $this->updateVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVcsRootEntryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVcsRootEntryAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        $returnType = '\TeamCityClient\Model\VcsRootEntry';
        $request = $this->updateVcsRootEntryRequest($bt_locator, $vcs_root_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVcsRootEntry'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \TeamCityClient\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateVcsRootEntryRequest($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateVcsRootEntry'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling updateVcsRootEntry'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVcsRootEntryCheckoutRules
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function updateVcsRootEntryCheckoutRules($bt_locator, $vcs_root_locator, $body = null)
    {
        list($response) = $this->updateVcsRootEntryCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator, $body);
        return $response;
    }

    /**
     * Operation updateVcsRootEntryCheckoutRulesWithHttpInfo
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \TeamCityClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVcsRootEntryCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVcsRootEntryCheckoutRulesAsync
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVcsRootEntryCheckoutRulesAsync($bt_locator, $vcs_root_locator, $body = null)
    {
        return $this->updateVcsRootEntryCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVcsRootEntryCheckoutRulesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVcsRootEntryCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVcsRootEntryCheckoutRules'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateVcsRootEntryCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateVcsRootEntryCheckoutRules'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling updateVcsRootEntryCheckoutRules'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}/checkout-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '.$this->config->getAccessToken();
        } elseif ($this->config->getUsername() && $this->config->getPassword()) {
            $defaultHeaders['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() .':'. $this->config->getPassword());
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
